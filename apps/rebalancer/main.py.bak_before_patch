import os, json, argparse, math, datetime, statistics
from pathlib import Path
from libs.db import get_conn
from libs.logger import get_logger

log = get_logger("rebalancer")
BASE = Path(__file__).resolve().parents[2]
CFG_PATH = BASE / "configs" / "policy.rebalancer.json"

def load_cfg():
    with open(CFG_PATH, "r", encoding="utf-8") as f:
        return json.load(f)

def latest_price(conn, instr):
    r = conn.execute("SELECT px FROM price WHERE instrument_id=? ORDER BY ts DESC LIMIT 1",(instr,)).fetchone()
    return r["px"] if r else None

def latest_qty(conn, account, instr):
    r = conn.execute("SELECT qty FROM balance_snapshot WHERE account_id=? AND instrument_id=? ORDER BY ts DESC LIMIT 1",(account, instr)).fetchone()
    return r["qty"] if r else 0.0

def round_step(qty, step):
    if not step or step <= 0: return qty
    return math.floor(qty / step) * step  # round down so we never overspend/oversell

# ---- helpers for daily series, lookback returns, and vol ----

def _daily_series(conn, symbol, max_days):
    # Build per-day latest close from price table (robust to multiple ticks per day)
    rows = conn.execute("SELECT ts, px FROM price WHERE instrument_id=? ORDER BY ts DESC LIMIT 50000",(symbol,)).fetchall()
    by_day = {}
    for r in rows:
        d = r["ts"][:10]
        if d not in by_day:
            by_day[d] = r["px"]   # first seen is the latest that day (DESC)
        if len(by_day) >= max_days + 3:
            # enough coverage; keep scanning in case of gaps, but this is fast anyway
            pass
    days = sorted(by_day.keys())
    if len(days) < 2: return []
    # return last max_days+1 points ascending
    days = days[-(max_days+1):]
    return [(d, by_day[d]) for d in days]

def lookback_return(conn, symbol, look):
    ser = _daily_series(conn, symbol, look)
    if len(ser) < 2: return None
    start_px = ser[0][1]; end_px = ser[-1][1]
    if start_px and start_px > 0:
        return end_px / start_px - 1.0
    return None

def symbol_ann_vol(conn, symbol, look):
    ser = _daily_series(conn, symbol, look)
    if len(ser) < 3: return None
    pxs = [v for _,v in ser]
    rets = []
    for i in range(1,len(pxs)):
        if pxs[i-1] and pxs[i-1] > 0:
            rets.append(pxs[i]/pxs[i-1] - 1.0)
    if len(rets) < 2: return None
    sd = statistics.stdev(rets)
    return sd * math.sqrt(365.0)

def portfolio_ann_vol(conn, symbols, weights, look):
    # diagonal-only proxy: sqrt(sum (w_i^2 * vol_i^2))
    var = 0.0; any_vol=False
    for s in symbols:
        vol = symbol_ann_vol(conn, s, look)
        if vol is not None:
            any_vol=True
            var += (weights.get(s,0.0)**2) * (vol**2)
    return math.sqrt(var) if any_vol else None

def compute_actions(account="trading", override_prices=None):
    cfg = load_cfg()
    # base policy targets as { "BTC": 0.40, ... }
    base_targets = cfg.get("targets_trading", {})
    # working targets dict keyed by base symbols (BTC/ETH/...)
    targets = { k.upper(): float(v) for k,v in base_targets.items() if k.upper() != "USD" }

    band_cfg = cfg.get("band_dynamic", {})
    band = float(cfg.get("bands_pct", 0.05))  # legacy base band (used if dynamic disabled)
    min_usd = float(cfg.get("min_trade_usd", 1000))
    move_fraction = float(cfg.get("move_fraction", 0.5))
    daily_cap = float(cfg.get("daily_turnover_cap_usd", 1e15))
    per_asset_caps = { (k.upper()+"-USD"): float(v) for k, v in cfg.get("per_asset_cap_usd", {}).items() }
    fee_bps = float(cfg.get("taker_fee_bps", 0.0))
    slip_bps = float(cfg.get("slippage_bps", 0.0))
    qty_step = { (k.upper()+"-USD"): float(v) for k, v in cfg.get("qty_step", {}).items() }
    max_trade_count = int(cfg.get("max_trade_count", 99))
    ensure_cash = bool(cfg.get("ensure_cash", True))

    # optional features
    mom = cfg.get("momentum", {})
    mom_en = bool(mom.get("enabled", False))
    mom_look = int(mom.get("lookback_days",60))
    mom_tilt_max = float(mom.get("tilt_max_pct",0.05))
    mom_strength = float(mom.get("tilt_strength",1.0))

    gate = cfg.get("satellite_gate", {})
    gate_en = bool(gate.get("enabled", False))
    gate_syms = [s.upper() for s in gate.get("symbols", [])]
    gate_look = int(gate.get("lookback_days", 60))
    gate_thr = float(gate.get("threshold_ret", 0.0))
    gate_maxw = { k.upper(): float(v) for k,v in gate.get("max_weight_pct", {}).items() }

    cash_cfg = cfg.get("cash", {})
    cash_floor = float(cash_cfg.get("floor_usd", 0.0))
    cash_deploy = float(cash_cfg.get("auto_deploy_usd_per_day", 0.0))
    cash_prorata = bool(cash_cfg.get("pro_rata_underweights", True))

    dyn_en   = bool(band_cfg.get("enabled", False))
    dyn_base = float(band_cfg.get("base", band))
    dyn_look = int(band_cfg.get("lookback_days", 30))
    dyn_tgtv = float(band_cfg.get("target_ann_vol", 0.35))
    dyn_min  = float(band_cfg.get("min", 0.02))
    dyn_max  = float(band_cfg.get("max", 0.08))

    # instrument symbols ("BTC-USD", ...)
    symbols = sorted([f"{k.upper()}-USD" for k in targets.keys() if k.upper() != "USD"])
    conn = get_conn()

    # Gather prices/balances
    px = {}; qty = {}
    for s in symbols:
        px[s] = latest_price(conn, s)
        qty[s] = latest_qty(conn, account, s)
    usd = latest_qty(conn, account, "USD")
    # Apply overrides (what-if)
    if override_prices:
        for k, v in override_prices.items():
            k = str(k).strip()
            if k in px:
                try:
                    px[k] = float(v)
                except Exception:
                    pass
    # sanity: missing prices?
    missing = [s for s in symbols if not px[s]]
    if missing:
        return {"error": f"Missing prices for: {', '.join(missing)}"}


