# This script will properly fix your ops.ps1 file

Set-Location "F:\CryptoOps\crypto-ops"

# Backup current file
$timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
Copy-Item "win\ops.ps1" "win\ops.ps1.broken_$timestamp" -Force
Write-Host "✓ Created backup: win\ops.ps1.broken_$timestamp" -ForegroundColor Green

# Read the file
$content = Get-Content "win\ops.ps1" -Raw

# Find where the proper functions end and the broken ones begin
# The file should have proper functions up to around line 116, then broken stuff
# We'll find the last good function and cut there

# Split into lines
$lines = $content -split "`r?`n"

# Find the line with the first broken function body (around line 117)
# It starts with: $sa = "cryptoops-run@$Project.iam.gserviceaccount.com"
$brokenStartIndex = -1
for ($i = 0; $i -lt $lines.Count; $i++) {
    if ($lines[$i] -match '^\s*\$sa = "cryptoops-run@\$Project\.iam\.gserviceaccount\.com"') {
        $brokenStartIndex = $i
        Write-Host "Found broken code starting at line $($i + 1)" -ForegroundColor Yellow
        break
    }
}

# If we found the broken section, remove everything from there
if ($brokenStartIndex -gt 0) {
    $goodLines = $lines[0..($brokenStartIndex - 1)]
    $cleanContent = $goodLines -join "`r`n"
} else {
    Write-Host "Could not find the broken section, will clean the entire file" -ForegroundColor Yellow
    $cleanContent = $content
}

# Now append the COMPLETE, PROPER functions
$properFunctions = @'

# ========== FIXED FUNCTIONS ==========

function Get-RunToken { 
    [CmdletBinding()]
    param(
        [string]$Service = 'cryptoops-planner',
        [string]$Region = 'us-central1'
    )
    
    try {
        $ctx = Get-Context -Service $Service -Region $Region
        
        # Properly expand variables to avoid impersonation error
        $url = $ctx.Url
        $sa = $ctx.SA
        
        Write-Verbose "Getting token for service: $Service"
        Write-Verbose "Service URL: $url"
        Write-Verbose "Service Account: $sa"
        
        $token = gcloud auth print-identity-token `
            --audiences="$url" `
            --impersonate-service-account="$sa" `
            2>$null
            
        if (-not $token) {
            throw "No token returned from gcloud. Check that you have 'Service Account Token Creator' role."
        }
        
        return $token
    }
    catch {
        Write-Error "Failed to get auth token: $_"
        
        # Provide helpful error message
        if ($_ -match "serviceAccountTokenCreator") {
            $userEmail = gcloud config get-value account
            $project = gcloud config get-value core/project
            Write-Host "`nTo fix this, run:" -ForegroundColor Yellow
            Write-Host "gcloud iam service-accounts add-iam-policy-binding \" -ForegroundColor White
            Write-Host "  $sa \" -ForegroundColor White
            Write-Host "  --member='user:$userEmail' \" -ForegroundColor White
            Write-Host "  --role='roles/iam.serviceAccountTokenCreator'" -ForegroundColor White
        }
        
        return $null
    }
}

function Get-CloudRun5xxRatio {
    [CmdletBinding()]
    param(
        [string]$Project = (gcloud config get-value core/project),
        [string]$Service = 'cryptoops-planner',
        [int]$WindowMinutes = 5
    )

    $end   = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
    $start = (Get-Date).ToUniversalTime().AddMinutes(-$WindowMinutes).ToString('yyyy-MM-ddTHH:mm:ssZ')

    # Per-minute deltas, sum across series, group by service
    $agg = @{
        alignmentPeriod    = '60s'
        perSeriesAligner   = 'ALIGN_DELTA'
        crossSeriesReducer = 'REDUCE_SUM'
        groupByFields      = @('resource.labels.service_name')
    }

    # Build filters
    $base  = ('metric.type="run.googleapis.com/request_count" AND ' +
              'resource.type="cloud_run_revision" AND ' +
              'resource.labels.service_name="{0}"') -f $Service
    $fltNum = $base + ' AND metric.labels.response_code_class="5xx"'
    $fltDen = $base

    # Query Monitoring API
    try {
        $respNum = Get-MonTimeSeries -Project $Project -Filter $fltNum -StartTime $start -EndTime $end -Aggregation $agg
        $respDen = Get-MonTimeSeries -Project $Project -Filter $fltDen -StartTime $start -EndTime $end -Aggregation $agg
    }
    catch {
        Write-Warning "Failed to query monitoring API: $_"
        return [pscustomobject]@{
            window_start_utc = $start
            window_end_utc   = $end
            service          = $Service
            last_minute      = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
            window           = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
        }
    }

    # Helper function to safely extract values from response
    function Get-TimeSeriesValues($resp) {
        $values = @()
        
        if ($null -eq $resp) { return $values }
        if (-not ($resp.PSObject.Properties.Name -contains 'timeSeries')) { return $values }
        
        $ts = $resp.timeSeries
        if ($null -eq $ts) { return $values }
        
        # Normalize to array
        if ($ts -isnot [System.Array]) { $ts = @($ts) }
        if ($ts.Length -eq 0) { return $values }
        
        $series = $ts[0]
        if (-not ($series.PSObject.Properties.Name -contains 'points')) { return $values }
        if ($null -eq $series.points) { return $values }
        
        # Sort points by time
        $points = $series.points | Sort-Object { [DateTimeOffset]::Parse($_.interval.endTime) }
        
        foreach ($pt in $points) {
            if ($null -eq $pt.value) { continue }
            
            $v = $null
            if ($pt.value.PSObject.Properties.Name -contains 'doubleValue') {
                $v = [double]$pt.value.doubleValue
            }
            elseif ($pt.value.PSObject.Properties.Name -contains 'int64Value') {
                $v = [double]$pt.value.int64Value
            }
            
            if ($null -ne $v) {
                $values += $v
            }
        }
        
        return $values
    }

    # Extract values safely
    $numVals = @(Get-TimeSeriesValues $respNum)
    $denVals = @(Get-TimeSeriesValues $respDen)

    # Calculate last minute metrics
    $lastNum   = if ($numVals.Length -gt 0) { $numVals[-1] } else { 0.0 }
    $lastDen   = if ($denVals.Length -gt 0) { $denVals[-1] } else { 0.0 }
    $lastRatio = if ($lastDen -gt 0) { [math]::Round($lastNum / $lastDen, 4) } else { $null }

    # Calculate window totals
    $sumNum = ($numVals | Measure-Object -Sum).Sum
    $sumDen = ($denVals | Measure-Object -Sum).Sum
    if ($null -eq $sumNum) { $sumNum = 0.0 }
    if ($null -eq $sumDen) { $sumDen = 0.0 }
    $windowRatio = if ($sumDen -gt 0) { [math]::Round($sumNum / $sumDen, 4) } else { $null }

    # Return results
    [pscustomobject]@{
        window_start_utc = $start
        window_end_utc   = $end
        service          = $Service
        last_minute      = [pscustomobject]@{ 
            total      = $lastDen
            errors_5xx = $lastNum
            ratio      = $lastRatio 
        }
        window = [pscustomobject]@{ 
            total      = $sumDen
            errors_5xx = $sumNum
            ratio      = $windowRatio 
        }
    }
}

Write-Host "Loaded win\ops.ps1 helpers. Dot-source this file in each new PowerShell session:  . .\win\ops.ps1"
'@

# Combine clean content with proper functions
$finalContent = $cleanContent.TrimEnd() + "`r`n" + $properFunctions

# Save the fixed file
Set-Content "win\ops.ps1" -Value $finalContent -Encoding UTF8
Write-Host "✓ Fixed win\ops.ps1" -ForegroundColor Green

# Reload in current session
Write-Host "`nReloading functions..." -ForegroundColor Cyan
. .\win\ops.ps1

# Verify the functions are loaded
Write-Host "`n✓ Available functions:" -ForegroundColor Green
Get-Command Get-RunToken, Get-CloudRun5xxRatio -ErrorAction SilentlyContinue | 
    Format-Table Name, CommandType -AutoSize

# Test the functions
Write-Host "`nTesting Get-RunToken..." -ForegroundColor Cyan
try {
    $token = Get-RunToken -Verbose
    if ($token) {
        Write-Host "✓ Token obtained (length: $($token.Length))" -ForegroundColor Green
    }
} catch {
    Write-Host "✗ Token failed: $_" -ForegroundColor Red
}

Write-Host "`nTesting Get-CloudRun5xxRatio..." -ForegroundColor Cyan
try {
    $metrics = Get-CloudRun5xxRatio -WindowMinutes 5
    if ($metrics) {
        Write-Host "✓ Metrics retrieved:" -ForegroundColor Green
        Write-Host "  Window: $($metrics.window_start_utc) to $($metrics.window_end_utc)"
        Write-Host "  Total requests: $($metrics.window.total)"
        Write-Host "  5xx errors: $($metrics.window.errors_5xx)"
        Write-Host "  Error ratio: $($metrics.window.ratio)"
    }
} catch {
    Write-Host "Note: $_" -ForegroundColor Yellow
}

Write-Host "`n✅ Fix complete!" -ForegroundColor Green