# service/main.py
import os, time, math, statistics, hashlib, subprocess, uuid, json as _json
from typing import Optional, List, Dict, Any
from pathlib import Path

from fastapi import FastAPI, Query, Header, HTTPException
import requests

from apps.rebalancer.main import compute_actions
from apps.infra.state_gcs import read_json, write_json, append_jsonl

# Optional helpers from state_gcs; fall back if not present.
try:
    from apps.infra.state_gcs import read_ndjson, selftest, read_text  # type: ignore
except Exception:
    read_ndjson = None
    selftest = None
    read_text = None

app = FastAPI(title="CryptoOps Planner", version="1.4")

# ------------------------------------------------------------------------
# helpers
# ------------------------------------------------------------------------

def _git_commit() -> str:
    try:
        out = subprocess.check_output(["git","rev-parse","--short","HEAD"], stderr=subprocess.DEVNULL)
        return out.decode().strip()
    except Exception:
        return "n/a"

def _config_hash() -> str:
    try:
        cfg_path = Path(__file__).resolve().parents[1] / "configs" / "policy.rebalancer.json"
        s = cfg_path.read_text(encoding="utf-8")
    except Exception:
        s = "{}"
    return hashlib.sha256(s.encode()).hexdigest()[:12]

def _mode_payload() -> Dict[str, Any]:
    return {
        "trading_mode": os.getenv("TRADING_MODE","paper"),
        "coinbase_env": os.getenv("COINBASE_ENV","sandbox"),
        "state_bucket": os.getenv("STATE_BUCKET","(unset)"),
        "revision": os.getenv("K_REVISION","n/a"),
        "code_commit": _git_commit(),
        "config_hash": _config_hash(),
        "run_id": str(uuid.uuid4()),
        "ts": int(time.time()),
    }

def _apply_actions(bal: Dict[str, float], actions: List[Dict]) -> Dict[str, float]:
    b = {k: float(v) for k, v in (bal or {}).items()}
    for a in actions or []:
        sym = a["symbol"]; side = a["side"].lower()
        qty = float(a["qty"]); usd = float(a["usd"])
        if side == "buy":
            b[sym] = float(b.get(sym,0.0)) + qty
            b["USD"] = float(b.get("USD",0.0)) - usd
        elif side == "sell":
            b[sym] = float(b.get(sym,0.0)) - qty
            b["USD"] = float(b.get("USD",0.0)) + usd
    return b

def _nav(bal: Dict[str,float], prices: Dict[str,float]) -> float:
    nav = float((bal or {}).get("USD",0.0))
    for k, q in (bal or {}).items():
        if k.endswith("-USD") and k in (prices or {}):
            nav += float(q) * float(prices[k])
    return nav

def _ts_str(ts: Optional[int] = None) -> str:
    ts = ts or int(time.time())
    return time.strftime("%Y%m%d_%H%M%S", time.gmtime(ts))

def _is_sunday(ts: Optional[int] = None) -> bool:
    return time.gmtime(ts or int(time.time())).tm_wday == 6  # Monday=0 ... Sunday=6

def _safe_read_ndjson(path: str) -> List[dict]:
    """Use state_gcs.read_ndjson if present, else parse text manually."""
    if read_ndjson:
        try:
            return read_ndjson(path)  # type: ignore
        except Exception:
            return []
    try:
        if read_text is None:
            return []
        txt = read_text(path)
        if not txt:
            return []
        out = []
        for ln in txt.splitlines():
            ln = ln.strip()
            if ln:
                try:
                    out.append(_json.loads(ln))
                except Exception:
                    pass
        return out
    except Exception:
        return []

def _load_targets_from_policy() -> Dict[str, float]:
    """
    Pull target weights from configs/policy.rebalancer.json.
    Fallback to a reasonable 4-asset split if file missing.
    """
    try:
        cfg_path = Path(__file__).resolve().parents[1] / "configs" / "policy.rebalancer.json"
        data = _json.loads(cfg_path.read_text(encoding="utf-8"))
        t = data.get("targets_trading") or data.get("targets") or {}
        return {k.upper(): float(v) for k, v in t.items()}
    except Exception:
        return {"BTC": 0.45, "ETH": 0.25, "SOL": 0.15, "LINK": 0.15}

def _pairs_from_targets(t: Dict[str, float]) -> List[str]:
    return [f"{k}-USD" for k in t.keys()]

def _fetch_public_prices(pairs: List[str]) -> Dict[str, float]:
    """
    DB-free fallback using Coinbase public spot prices.
    """
    out: Dict[str, float] = {}
    for p in pairs:
        try:
            url = f"https://api.coinbase.com/v2/prices/{p}/spot"
            r = requests.get(url, timeout=5)
            amt = float(((r.json() or {}).get("data") or {}).get("amount"))
            out[p] = amt
        except Exception:
            pass
    return out

# ------------------------------------------------------------------------
# health/meta
# ------------------------------------------------------------------------

@app.get("/",            include_in_schema=False, tags=["meta"])
@app.get("/health",      include_in_schema=False, tags=["meta"])
@app.get("/healthz",     include_in_schema=False, tags=["meta"])
@app.get("/readyz",      include_in_schema=False, tags=["meta"])
@app.get("/_ah/health",  include_in_schema=False, tags=["meta"])
def health_all():
    return {"ok": True, **_mode_payload()}

@app.get("/mode", tags=["meta"])
def mode():
    return _mode_payload()

@app.get("/myip", tags=["meta"])
def myip():
    try:
        r = requests.get("https://api.ipify.org?format=json", timeout=5)
        return {"egress_ip": (r.json() or {}).get("ip")}
    except Exception as e:
        return {"error": f"ipify failed: {e.__class__.__name__}"}

@app.get("/gcs_selftest", tags=["meta"])
def gcs_selftest():
    if selftest is None:
        raise HTTPException(status_code=501, detail="selftest helper not available")
    ok, detail = selftest("state")
    return {"ok": ok, "detail": detail, **_mode_payload()}

# ------------------------------------------------------------------------
# plan + paper apply
# ------------------------------------------------------------------------

@app.get("/plan", tags=["planner"])
def plan(refresh: int = 0, pair: Optional[List[str]] = Query(default=None)):
    """
    Returns the current plan JSON.
    If the planner's DB is unavailable, returns a no-trade fallback with prices from GCS or Coinbase.
    Optional what-if overrides:
      /plan?pair=BTC-USD=125000&pair=SOL-USD=177
    """
    overrides: Dict[str, float] = {}
    for kv in (pair or []):
        if "=" in kv:
            k, v = kv.split("=", 1)
            try:
                overrides[k.strip()] = float(v)
            except Exception:
                pass

    try:
        return compute_actions("trading", override_prices=overrides or None)
    except Exception as e:
        prices = read_json("state/latest_prices.json", default=None)
        if not prices:
            targets = _load_targets_from_policy()
            prices = _fetch_public_prices(_pairs_from_targets(targets))
        balances = read_json("state/balances.json", default={}) or {}
        return {
            "account": "trading",
            "prices": prices or {},
            "balances": balances,
            "actions": [],
            "note": f"planner_fallback: {e.__class__.__name__}",
            "config": {"band": None},
        }

def _append_snapshots(ts: int, nav_before: float, nav_after: float, turnover_usd: float, actions_count: int, source: str):
    rec = {
        "ts": ts,
        "nav_before": round(nav_before, 2),
        "nav": round(nav_after, 2),
        "turnover_usd": round(turnover_usd, 2),
        "actions_count": int(actions_count),
        "source": source,
        "revision": os.getenv("K_REVISION","n/a"),
        "commit": True,
    }
    append_jsonl("snapshots/daily.jsonl", rec)
    if _is_sunday(ts):
        append_jsonl("snapshots/weekly.jsonl", rec)

@app.get("/apply_paper", tags=["planner"])
def apply_paper(
    commit: int = 0,
    refresh: int = 0,
    x_app_key: Optional[str] = Header(None),
    debug: int = 0
):
    expected = os.getenv("APP_KEY")
    if expected and x_app_key != expected:
        raise HTTPException(status_code=401, detail="missing/invalid app key")

    # Compute plan; for dry-run we tolerate planner failures and fall back.
    try:
        plan_obj = compute_actions("trading")
        planner_ok = True
    except Exception as e:
        planner_ok = False
        plan_obj = {"note": f"planner_unavailable: {e.__class__.__name__}"}

    if not planner_ok and commit:
        # For commit, we require planner. Return 503 so Scheduler shows failures clearly.
        raise HTTPException(status_code=503, detail=f"planner unavailable: {plan_obj.get('note','unknown')}")

    # Prices/balances for execution or dry-run
    if planner_ok:
        actions = plan_obj.get("actions", [])
        prices  = plan_obj.get("prices", {}) or {}
    else:
        actions = []
        targets = _load_targets_from_policy()
        prices  = read_json("state/latest_prices.json", default=None) or _fetch_public_prices(_pairs_from_targets(targets))
        plan_obj["prices"] = prices

    bal_path    = "state/balances.json"
    ts          = int(time.time())
    ts_str      = _ts_str(ts)
    run_id      = _mode_payload()["run_id"]
    trades_path = f"trades/{ts_str[:8]}.jsonl"
    plan_path   = f"plans/plan_{ts_str}_{run_id}.json"

    # Read balances (tolerant for dry-run)
    balances_before = None
    gcs_read_ok = True
    try:
        try:
            balances_before = read_json(bal_path, default=None)
        except TypeError:
            balances_before = read_json(bal_path)
    except Exception:
        gcs_read_ok = False
        if commit == 1:
            raise

    if balances_before is None:
        balances_before = plan_obj.get("balances", {}) or {}
        balances_before.setdefault("USD", 0.0)

    nav_before = _nav(balances_before, prices)
    balances_after = _apply_actions(balances_before, actions)
    nav_after  = _nav(balances_after, prices)

    turnover = sum(float(a.get("usd", 0)) for a in actions)
    summary = {
        "ok": True,
        "dry_run": (commit == 0),
        "actions_count": len(actions),
        "turnover_usd": round(turnover, 2),
        "nav_before": round(nav_before, 2),
        "nav_after": round(nav_after, 2),
    }
    if commit == 0 and not gcs_read_ok:
        summary["note"] = "GCS read failed; used plan balances for dry-run."
    if not planner_ok:
        summary["note"] = plan_obj.get("note", "planner_fallback")

    if commit:
        try:
            # Save plan (even if empty actions) and balances
            write_json(plan_path, plan_obj)
            write_json(bal_path, balances_after)
            # Remember latest prices for DB-free snapshots
            if prices:
                write_json("state/latest_prices.json", prices)

            # Log executed trades
            if actions:
                meta = {
                    "ts": ts,
                    "run_id": run_id,
                    "revision": os.getenv("K_REVISION","n/a"),
                    "code_commit": _git_commit(),
                    "plan_path": plan_path
                }
                for a in actions:
                    rec = dict(meta); rec.update(a)
                    append_jsonl(trades_path, rec)

            # Snapshot NAV after this tick
            _append_snapshots(
                ts=ts,
                nav_before=nav_before,
                nav_after=nav_after,
                turnover_usd=turnover,
                actions_count=len(actions),
                source="apply_paper"
            )

            summary["writes"] = {
                "balances": bal_path,
                "trades": trades_path,
                "plan": plan_path,
                "latest_prices": "state/latest_prices.json",
                "snapshots_daily": "snapshots/daily.jsonl",
                "snapshots_weekly": "snapshots/weekly.jsonl",
            }
        except Exception as e:
            msg = f"GCS write failed: {e.__class__.__name__}: {e}"
            if debug:
                raise HTTPException(status_code=500, detail=msg)
            raise

    return summary

# ------------------------------------------------------------------------
# snapshots + analytics
# ------------------------------------------------------------------------

@app.get("/snapshot_now", tags=["analytics"])
def snapshot_now(commit: int = 0, x_app_key: Optional[str] = Header(None), debug: int = 0):
    """
    Record a NAV snapshot using current balances and prices (no trade).
    Fallback if planner DB is unavailable.
    """
    expected = os.getenv("APP_KEY")
    if expected and x_app_key != expected:
        raise HTTPException(status_code=401, detail="missing/invalid app key")

    try:
        # Try planner (preferred, includes its pricing path)
        plan_obj = None
        try:
            plan_obj = compute_actions("trading")
            prices = plan_obj.get("prices", {}) or {}
        except Exception:
            # Fallback to last saved prices or public spot
            prices = read_json("state/latest_prices.json", default=None)
            if not prices:
                targets = _load_targets_from_policy()
                prices = _fetch_public_prices(_pairs_from_targets(targets))

        # Balances from state or plan as last resort
        balances = read_json("state/balances.json", default=None) or (plan_obj.get("balances", {}) if plan_obj else {})
        balances = balances or {}
        balances.setdefault("USD", 0.0)

        nav = _nav(balances, prices)
        ts  = int(time.time())

        if commit:
            rec = {
                "ts": ts,
                "nav_before": round(nav, 2),
                "nav": round(nav, 2),
                "turnover_usd": 0.0,
                "actions_count": 0,
                "source": "snapshot_now",
                "revision": os.getenv("K_REVISION","n/a"),
                "commit": True,
            }
            append_jsonl("snapshots/daily.jsonl", rec)
            if _is_sunday(ts):
                append_jsonl("snapshots/weekly.jsonl", rec)

        return {"ok": True, "committed": bool(commit), "ts": ts, "nav": round(nav, 2)}
    except Exception as e:
        if debug:
            raise HTTPException(status_code=500, detail=f"snapshot failed: {e.__class__.__name__}: {e}")
        raise

def _equity_series(days: int = 365) -> List[Dict[str, float]]:
    rows = _safe_read_ndjson("snapshots/daily.jsonl")
    if not rows:
        return []
    rows = sorted(rows, key=lambda r: int(r.get("ts", 0)))
    cutoff = int(time.time()) - days * 86400
    out = []
    for r in rows:
        ts = int(r.get("ts", 0))
        if ts >= cutoff:
            nav = r.get("nav")
            if nav is None:
                nav = r.get("nav_after", 0.0)
            out.append({"ts": ts, "nav": float(nav)})
    return out

def _metrics_from_series(series: List[Dict[str, float]]) -> Dict[str, float]:
    if len(series) < 2:
        last = series[-1]["nav"] if series else None
        return {
            "points": len(series),
            "last_nav": round(last, 2) if last is not None else None,
            "note": "Not enough data for statistics",
        }

    ts0, nav0 = series[0]["ts"], series[0]["nav"]
    tsN, navN = series[-1]["ts"], series[-1]["nav"]
    days = max(1, round((tsN - ts0) / 86400))

    rets = []
    for i in range(1, len(series)):
        n0 = series[i-1]["nav"]
        n1 = series[i]["nav"]
        if n0 > 0:
            rets.append((n1 / n0) - 1.0)

    if len(rets) >= 2:
        mu_d = statistics.mean(rets)
        sd_d = statistics.pstdev(rets) if len(rets) > 1 else 0.0
        vol_ann = (sd_d * math.sqrt(365.0)) if sd_d > 0 else 0.0
        sharpe = (mu_d / sd_d * math.sqrt(365.0)) if sd_d > 0 else None
    else:
        mu_d, vol_ann, sharpe = 0.0, 0.0, None

    total_ret = (navN / nav0) - 1.0 if nav0 > 0 else None
    cagr = ((navN / nav0) ** (365.0 / days) - 1.0) if (nav0 > 0 and days >= 1) else None

    peak = -1e18
    maxdd = 0.0
    for p in series:
        v = p["nav"]
        if v > peak:
            peak = v
        if peak > 0:
            dd = (v / peak) - 1.0
            if dd < maxdd:
                maxdd = dd

    return {
        "points": len(series),
        "first_ts": ts0,
        "last_ts": tsN,
        "days": days,
        "first_nav": round(nav0, 2),
        "last_nav": round(navN, 2),
        "total_return": round(total_ret, 6) if total_ret is not None else None,
        "cagr": round(cagr, 6) if cagr is not None else None,
        "vol_ann": round(vol_ann, 6),
        "sharpe": round(sharpe, 4) if sharpe is not None else None,
        "max_drawdown": round(maxdd, 6),
    }

@app.get("/equity_curve", tags=["analytics"])
def equity_curve(days: int = 365):
    series = _equity_series(days=days)
    return {"ok": True, "days": days, "series": series, **_mode_payload()}

@app.get("/metrics", tags=["analytics"])
def metrics(days: int = 365):
    series = _equity_series(days=days)
    m = _metrics_from_series(series)
    return {"ok": True, "days": days, "metrics": m, **_mode_payload()}

# ------------------------------------------------------------------------
# dev: run local
# ------------------------------------------------------------------------

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("service.main:app", host="127.0.0.1", port=8080, reload=True)
