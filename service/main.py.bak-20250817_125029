# service/main.py  (v1.6)
import os, time, math, statistics, hashlib, subprocess, uuid, json as _json
from typing import Optional, List, Dict, Any
from pathlib import Path

# --- CRITICAL: patch sqlite3 BEFORE importing your planner ---
import sqlite3 as _sqlite3

_LEDGER_DB = os.getenv("LEDGER_DB", "/tmp/ledger.db")
_sqlite3_connect_orig = _sqlite3.connect

def _connect_with_fallback(db, *args, **kwargs):
    """
    Try the requested DB. If it lacks a 'price' table and LEDGER_DB exists,
    transparently reconnect to LEDGER_DB. This handles modules that still
    open .../data/ledger.db internally.
    """
    try:
        con = _sqlite3_connect_orig(db, *args, **kwargs)
    except Exception:
        # If initial open fails, jump straight to LEDGER_DB if present.
        if _LEDGER_DB and os.path.exists(_LEDGER_DB):
            return _sqlite3_connect_orig(_LEDGER_DB, *args, **kwargs)
        raise

    try:
        cur = con.cursor()
        cur.execute("SELECT 1 FROM sqlite_master WHERE type='table' AND name='price'")
        row = cur.fetchone()
        if not row:
            # Re-route to LEDGER_DB if it exists
            con.close()
            if _LEDGER_DB and os.path.exists(_LEDGER_DB):
                return _sqlite3_connect_orig(_LEDGER_DB, *args, **kwargs)
    except Exception:
        # If the check fails for any reason, just return the connection
        pass
    return con

# Monkey-patch
_sqlite3.connect = _connect_with_fallback
# --------------------------------------------------------------------------

from fastapi import FastAPI, Query, Header, HTTPException
import requests

# Import after patch so all downstream sqlite3.connect calls are intercepted
from apps.rebalancer.main import compute_actions
from apps.infra.state_gcs import read_json, write_json, append_jsonl

# Optional helper (present in your state_gcs.py)
try:
    from apps.infra.state_gcs import read_ndjson, selftest  # type: ignore
except Exception:
    read_ndjson = None
    selftest = None

app = FastAPI(title="CryptoOps Planner", version="1.6")

# ------------------------------------------------------------------------
# helpers
# ------------------------------------------------------------------------

def _git_commit() -> str:
    try:
        out = subprocess.check_output(["git","rev-parse","--short","HEAD"], stderr=subprocess.DEVNULL)
        return out.decode().strip()
    except Exception:
        return "n/a"

def _config_hash() -> str:
    try:
        cfg_path = Path(__file__).resolve().parents[1] / "configs" / "policy.rebalancer.json"
        s = cfg_path.read_text(encoding="utf-8")
    except Exception:
        s = "{}"
    return hashlib.sha256(s.encode()).hexdigest()[:12]

def _mode_payload() -> Dict[str, Any]:
    return {
        "trading_mode": os.getenv("TRADING_MODE","paper"),
        "coinbase_env": os.getenv("COINBASE_ENV","sandbox"),
        "state_bucket": os.getenv("STATE_BUCKET","(unset)"),
        "revision": os.getenv("K_REVISION","n/a"),
        "code_commit": _git_commit(),
        "config_hash": _config_hash(),
        "run_id": str(uuid.uuid4()),
        "ts": int(time.time()),
    }

def _apply_actions(bal: Dict[str, float], actions: List[Dict]) -> Dict[str, float]:
    b = {k: float(v) for k, v in (bal or {}).items()}
    for a in actions or []:
        sym = a["symbol"]; side = a["side"].lower()
        qty = float(a["qty"]); usd = float(a["usd"])
        if side == "buy":
            b[sym] = float(b.get(sym,0.0)) + qty
            b["USD"] = float(b.get("USD",0.0)) - usd
        elif side == "sell":
            b[sym] = float(b.get(sym,0.0)) - qty
            b["USD"] = float(b.get("USD",0.0)) + usd
    return b

def _nav(bal: Dict[str,float], prices: Dict[str,float]) -> float:
    nav = float((bal or {}).get("USD",0.0))
    for k, q in (bal or {}).items():
        if k.endswith("-USD") and k in (prices or {}):
            nav += float(q) * float(prices[k])
    return nav

def _ts_str(ts: Optional[int] = None) -> str:
    ts = ts or int(time.time())
    return time.strftime("%Y%m%d_%H%M%S", time.gmtime(ts))

def _is_sunday(ts: Optional[int] = None) -> bool:
    return time.gmtime(ts or int(time.time())).tm_wday == 6  # Monday=0 ... Sunday=6

def _safe_read_ndjson(path: str) -> List[dict]:
    if read_ndjson:
        try:
            return read_ndjson(path)  # type: ignore
        except Exception:
            return []
    try:
        from apps.infra.state_gcs import read_text
        txt = read_text(path)
        if not txt:
            return []
        out = []
        for ln in txt.splitlines():
            ln = ln.strip()
            if ln:
                try:
                    out.append(_json.loads(ln))
                except Exception:
                    pass
        return out
    except Exception:
        return []

def _load_targets_from_policy() -> Dict[str, float]:
    try:
        cfg_path = Path(__file__).resolve().parents[1] / "configs" / "policy.rebalancer.json"
        data = _json.loads(cfg_path.read_text(encoding="utf-8"))
        t = data.get("targets_trading") or data.get("targets") or {}
        return {k.upper(): float(v) for k, v in t.items()}
    except Exception:
        return {"BTC": 0.45, "ETH": 0.25, "SOL": 0.15, "LINK": 0.15}

def _pairs_from_targets(t: Dict[str, float]) -> List[str]:
    return [f"{k}-USD" for k in t.keys()]

def _fetch_public_prices(pairs: List[str]) -> Dict[str, float]:
    out: Dict[str, float] = {}
    for p in pairs:
        try:
            url = f"https://api.coinbase.com/v2/prices/{p}/spot"
            r = requests.get(url, timeout=5)
            amt = float(((r.json() or {}).get("data") or {}).get("amount"))
            out[p] = amt
        except Exception:
            pass
    return out

# ---------- Ensure the ledger DB exists locally ----------
def _ensure_ledger_db(force: bool = False) -> Dict[str, Any]:
    """
    If LEDGER_DB_GCS and LEDGER_DB are set and the local file is missing (or force=True),
    download gs://... to the local path (e.g., /tmp/ledger.db). Returns status dict.
    """
    gcs_uri = os.getenv("LEDGER_DB_GCS")
    local_path = os.getenv("LEDGER_DB")
    status = {"gcs": gcs_uri, "local": local_path, "downloaded": False, "exists": False}
    if not gcs_uri or not local_path:
        return status

    if (not force) and os.path.exists(local_path):
        status["exists"] = True
        return status

    try:
        if not gcs_uri.startswith("gs://"):
            return status
        rest = gcs_uri[5:]
        bucket_name, blob_name = rest.split("/", 1)

        from google.cloud import storage  # lazy import
        Path(local_path).parent.mkdir(parents=True, exist_ok=True)
        client = storage.Client()
        bucket = client.bucket(bucket_name)
        blob = bucket.blob(blob_name)
        blob.download_to_filename(local_path)
        status.update({"downloaded": True, "exists": True})
    except Exception:
        pass
    return status

@app.on_event("startup")
def _startup_fetch_db():
    _ensure_ledger_db(force=False)

# ------------------------------------------------------------------------
# health/meta
# ------------------------------------------------------------------------

@app.get("/",            include_in_schema=False, tags=["meta"])
@app.get("/health",      include_in_schema=False, tags=["meta"])
@app.get("/healthz",     include_in_schema=False, tags=["meta"])
@app.get("/readyz",      include_in_schema=False, tags=["meta"])
@app.get("/_ah/health",  include_in_schema=False, tags=["meta"])
def health_all():
    # Expose basic info + whether the local DB exists
    exists = bool(_LEDGER_DB and os.path.exists(_LEDGER_DB))
    db_info = None
    if exists:
        st = os.stat(_LEDGER_DB)
        db_info = {
            "path": _LEDGER_DB,
            "exists": True,
            "size": st.st_size,
            "mtime_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(st.st_mtime)),
        }
    return {"ok": True, "db": db_info, **_mode_payload()}

@app.get("/mode", tags=["meta"])
def mode():
    return _mode_payload()

@app.get("/myip", tags=["meta"])
def myip():
    try:
        r = requests.get("https://api.ipify.org?format=json", timeout=5)
        return {"egress_ip": (r.json() or {}).get("ip")}
    except Exception as e:
        return {"error": f"ipify failed: {e.__class__.__name__}"}

@app.get("/gcs_selftest", tags=["meta"])
def gcs_selftest():
    if selftest is None:
        raise HTTPException(status_code=501, detail="selftest helper not available")
    ok, detail = selftest("state")
    return {"ok": ok, "detail": detail, **_mode_payload()}

# Debug: show tables/columns/symbol coverage
@app.get("/planner_debug_db", tags=["meta"])
def planner_debug_db():
    info = {"ok": True, **_mode_payload()}
    p = _LEDGER_DB
    if p and os.path.exists(p):
        st = os.stat(p)
        info["db"] = {
            "path": p,
            "exists": True,
            "size": st.st_size,
            "mtime_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(st.st_mtime)),
        }
        try:
            con = _sqlite3.connect(p)
            cur = con.cursor()
            cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
            info["tables"] = [r[0] for r in cur.fetchall()]
            cur.execute("PRAGMA table_info(price)")
            info["price_columns"] = [r[1] for r in cur.fetchall()]
            syms = {}
            for s in ("BTC-USD","ETH-USD","SOL-USD","LINK-USD"):
                cur.execute("SELECT COUNT(*), MIN(ts), MAX(ts) FROM price WHERE symbol=?", (s,))
                cnt, mn, mx = cur.fetchone()
                syms[s] = {"count": cnt, "min_ts": mn, "max_ts": mx}
            info["symbols"] = syms
            con.close()
        except Exception as e:
            info["error"] = f"{e.__class__.__name__}: {e}"
    else:
        info["db"] = {"path": p or "(unset)", "exists": False}
    return info

# Force re-download of the DB from GCS
@app.get("/planner_force_refresh", tags=["meta"])
def planner_force_refresh():
    st = _ensure_ledger_db(force=True)
    return {"ok": True, "status": st, **_mode_payload()}

# ------------------------------------------------------------------------
# plan + paper apply
# ------------------------------------------------------------------------

@app.get("/plan", tags=["planner"])
def plan(refresh: int = 0, pair: Optional[List[str]] = Query(default=None), debug: int = 0):
    """
    Returns the current plan JSON.
    If the planner's DB is unavailable, returns a no-trade fallback with prices from GCS or Coinbase.
    Optional what-if overrides, e.g.:
      /plan?pair=BTC-USD=125000&pair=SOL-USD=177
    """
    _ensure_ledger_db(force=bool(refresh))
    overrides: Dict[str, float] = {}
    for kv in (pair or []):
        if "=" in kv:
            k, v = kv.split("=", 1)
            try:
                overrides[k.strip()] = float(v)
            except Exception:
                pass

    try:
        return compute_actions("trading", override_prices=overrides or None)
    except Exception as e:
        # Fallback: try last saved prices in GCS, otherwise public spot
        prices = read_json("state/latest_prices.json", default=None)
        if not prices:
            targets = _load_targets_from_policy()
            prices = _fetch_public_prices(_pairs_from_targets(targets))
        balances = read_json("state/balances.json", default={}) or {}
        note = f"planner_fallback: {e.__class__.__name__}"
        if debug:
            note += f" | {e}"
        return {
            "account": "trading",
            "prices": prices or {},
            "balances": balances,
            "actions": [],
            "note": note,
            "config": {"band": None},
        }

def _append_snapshots(ts: int, nav_before: float, nav_after: float, turnover_usd: float, actions_count: int, source: str):
    rec = {
        "ts": ts,
        "nav_before": round(nav_before, 2),
        "nav": round(nav_after, 2),
        "turnover_usd": round(turnover_usd, 2),
        "actions_count": int(actions_count),
        "source": source,
        "revision": os.getenv("K_REVISION","n/a"),
        "commit": True,
    }
    append_jsonl("snapshots/daily.jsonl", rec)
    if _is_sunday(ts):
        append_jsonl("snapshots/weekly.jsonl", rec)

@app.get("/apply_paper", tags=["planner"])
def apply_paper(
    commit: int = 0,
    refresh: int = 0,
    x_app_key: Optional[str] = Header(None),
    debug: int = 0
):
    expected = os.getenv("APP_KEY")
    # If you’ve locked Cloud Run behind OIDC (recommended), APP_KEY isn’t required for Scheduler.
    if expected and x_app_key != expected and not os.getenv("SKIP_APP_KEY"):
        raise HTTPException(status_code=401, detail="missing/invalid app key")

    _ensure_ledger_db(force=bool(refresh))

    # Try the real planner; if that fails and commit=1, bubble a 503.
    try:
        plan = compute_actions("trading")
    except Exception as e:
        if commit:
            raise HTTPException(status_code=503, detail=f"planner unavailable: {e.__class__.__name__}")
        # dry-run fallback
        prices = read_json("state/latest_prices.json", default=None)
        if not prices:
            targets = _load_targets_from_policy()
            prices = _fetch_public_prices(_pairs_from_targets(targets))
        balances_before = read_json("state/balances.json", default={}) or {}
        nav = _nav(balances_before, prices or {})
        return {
            "ok": True,
            "dry_run": True,
            "actions_count": 0,
            "turnover_usd": 0,
            "nav_before": round(nav,2),
            "nav_after": round(nav,2),
            "note": f"planner_fallback: {e.__class__.__name__}",
        }

    actions = plan.get("actions", [])
    prices  = plan.get("prices", {}) or {}

    bal_path    = "state/balances.json"
    ts          = int(time.time())
    ts_str      = _ts_str(ts)
    run_id      = _mode_payload()["run_id"]
    trades_path = f"trades/{ts_str[:8]}.jsonl"
    plan_path   = f"plans/plan_{ts_str}_{run_id}.json"

    # Read balances (tolerant for dry-run)
    balances_before = None
    gcs_read_ok = True
    try:
        try:
            balances_before = read_json(bal_path, default=None)
        except TypeError:
            balances_before = read_json(bal_path)
    except Exception:
        gcs_read_ok = False
        if commit == 1:
            raise

    if balances_before is None:
        balances_before = plan.get("balances", {}) or {}
        balances_before.setdefault("USD", 0.0)

    nav_before = _nav(balances_before, prices)
    balances_after = _apply_actions(balances_before, actions)
    nav_after  = _nav(balances_after, prices)

    turnover = sum(float(a.get("usd", 0)) for a in actions)
    summary = {
        "ok": True,
        "dry_run": (commit == 0),
        "actions_count": len(actions),
        "turnover_usd": round(turnover, 2),
        "nav_before": round(nav_before, 2),
        "nav_after": round(nav_after, 2),
    }
    if commit == 0 and not gcs_read_ok:
        summary["note"] = "GCS read failed; used plan balances for dry-run."

    if commit:
        try:
            write_json(plan_path, plan)
            write_json(bal_path, balances_after)
            if prices:
                write_json("state/latest_prices.json", prices)

            if actions:
                meta = {
                    "ts": ts,
                    "run_id": run_id,
                    "revision": os.getenv("K_REVISION","n/a"),
                    "code_commit": _git_commit(),
                    "plan_path": plan_path
                }
                for a in actions:
                    rec = dict(meta); rec.update(a)
                    append_jsonl(trades_path, rec)

            _append_snapshots(
                ts=ts,
                nav_before=nav_before,
                nav_after=nav_after,
                turnover_usd=turnover,
                actions_count=len(actions),
                source="apply_paper"
            )

            summary["writes"] = {
                "balances": bal_path,
                "trades": trades_path,
                "plan": plan_path,
                "latest_prices": "state/latest_prices.json",
                "snapshots_daily": "snapshots/daily.jsonl",
                "snapshots_weekly": "snapshots/weekly.jsonl",
            }
        except Exception as e:
            msg = f"GCS write failed: {e.__class__.__name__}: {e}"
            if debug:
                raise HTTPException(status_code=500, detail=msg)
            raise

    return summary

# ------------------------------------------------------------------------
# snapshots + analytics
# ------------------------------------------------------------------------

@app.get("/snapshot_now", tags=["analytics"])
def snapshot_now(commit: int = 0, x_app_key: Optional[str] = Header(None), debug: int = 0):
    expected = os.getenv("APP_KEY")
    if expected and x_app_key != expected and not os.getenv("SKIP_APP_KEY"):
        raise HTTPException(status_code=401, detail="missing/invalid app key")

    _ensure_ledger_db()

    try:
        try:
            plan = compute_actions("trading")
            prices = plan.get("prices", {}) or {}
            balances = read_json("state/balances.json", default=None) or plan.get("balances", {}) or {}
        except Exception:
            prices = read_json("state/latest_prices.json", default=None)
            if not prices:
                targets = _load_targets_from_policy()
                prices = _fetch_public_prices(_pairs_from_targets(targets))
            balances = read_json("state/balances.json", default={}) or {}
        balances.setdefault("USD", 0.0)

        nav = _nav(balances, prices or {})
        ts  = int(time.time())

        if commit:
            rec = {
                "ts": ts,
                "nav_before": round(nav, 2),
                "nav": round(nav, 2),
                "turnover_usd": 0.0,
                "actions_count": 0,
                "source": "snapshot_now",
                "revision": os.getenv("K_REVISION","n/a"),
                "commit": True,
            }
            append_jsonl("snapshots/daily.jsonl", rec)
            if _is_sunday(ts):
                append_jsonl("snapshots/weekly.jsonl", rec)

        return {"ok": True, "committed": bool(commit), "ts": ts, "nav": round(nav, 2)}
    except Exception as e:
        if debug:
            raise HTTPException(status_code=500, detail=f"snapshot failed: {e.__class__.__name__}: {e}")
        raise

def _equity_series(days: int = 365) -> List[Dict[str, float]]:
    rows = _safe_read_ndjson("snapshots/daily.jsonl")
    if not rows:
        return []
    rows = sorted(rows, key=lambda r: int(r.get("ts", 0)))
    cutoff = int(time.time()) - days * 86400
    out = []
    for r in rows:
        ts = int(r.get("ts", 0))
        if ts >= cutoff:
            nav = r.get("nav")
            if nav is None:
                nav = r.get("nav_after", 0.0)
            out.append({"ts": ts, "nav": float(nav)})
    return out

def _metrics_from_series(series: List[Dict[str, float]]) -> Dict[str, float]:
    if len(series) < 2:
        last = series[-1]["nav"] if series else None
        return {
            "points": len(series),
            "last_nav": round(last, 2) if last is not None else None,
            "note": "Not enough data for statistics",
        }

    ts0, nav0 = series[0]["ts"], series[0]["nav"]
    tsN, navN = series[-1]["ts"], series[-1]["nav"]
    days = max(1, round((tsN - ts0) / 86400))

    rets = []
    for i in range(1, len(series)):
        n0 = series[i-1]["nav"]
        n1 = series[i]["nav"]
        if n0 > 0:
            rets.append((n1 / n0) - 1.0)

    if len(rets) >= 2:
        mu_d = statistics.mean(rets)
        sd_d = statistics.pstdev(rets) if len(rets) > 1 else 0.0
        vol_ann = (sd_d * math.sqrt(365.0)) if sd_d > 0 else 0.0
        sharpe = (mu_d / sd_d * math.sqrt(365.0)) if sd_d > 0 else None
    else:
        mu_d, vol_ann, sharpe = 0.0, 0.0, None

    total_ret = (navN / nav0) - 1.0 if nav0 > 0 else None
    cagr = ((navN / nav0) ** (365.0 / days) - 1.0) if (nav0 > 0 and days >= 1) else None

    peak = -1e18
    maxdd = 0.0
    for p in series:
        v = p["nav"]
        if v > peak:
            peak = v
        if peak > 0:
            dd = (v / peak) - 1.0
            if dd < maxdd:
                maxdd = dd

    return {
        "points": len(series),
        "first_ts": ts0,
        "last_ts": tsN,
        "days": days,
        "first_nav": round(nav0, 2),
        "last_nav": round(navN, 2),
        "total_return": round(total_ret, 6) if total_ret is not None else None,
        "cagr": round(cagr, 6) if cagr is not None else None,
        "vol_ann": round(vol_ann, 6),
        "sharpe": round(sharpe, 4) if sharpe is not None else None,
        "max_drawdown": round(maxdd, 6),
    }

@app.get("/equity_curve", tags=["analytics"])
def equity_curve(days: int = 365):
    series = _equity_series(days=days)
    return {"ok": True, "days": days, "series": series, **_mode_payload()}

@app.get("/metrics", tags=["analytics"])
def metrics(days: int = 365):
    series = _equity_series(days=days)
    m = _metrics_from_series(series)
    return {"ok": True, "days": days, "metrics": m, **_mode_payload()}

# ------------------------------------------------------------------------
# dev: run local
# ------------------------------------------------------------------------

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("service.main:app", host="127.0.0.1", port=8080, reload=True)
