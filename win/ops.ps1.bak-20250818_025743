# --- 1) Paths + backup ---
$ops = 'F:\CryptoOps\crypto-ops\win\ops.ps1'
Copy-Item $ops "$ops.bak-$(Get-Date -Format yyyyMMdd_HHmmss)" -Force

# --- 2) Load file ---
$body = Get-Content $ops -Raw -Encoding UTF8

# --- 3) Remove any stray placeholder markers youâ€™ve had before ---
$body = $body -replace '(?m)^\s*<PASTE THE FUNCTION BODY ABOVE HERE>\s*\r?\n',''

# --- 4) Drop EVERYTHING after any prior 'Loaded win\ops.ps1 helpers' banner (if present) ---
$body = $body -replace '(?s)^\s*(.*?)(?m:^\s*Write-Host\s+"Loaded win\\ops\.ps1 helpers.*$).*?$','$1'

# --- 5) Remove all previous Get-CloudRun5xxRatio definitions (safe even if none) ---
$body = $body -replace '(?s)function\s+Get-CloudRun5xxRatio\s*\{.*?\}\s*',''

# --- 6) Remove any previous Get-RunToken definitions (safe even if none) ---
$body = $body -replace '(?s)function\s+Get-RunToken\s*\{.*?\}\s*',''

# --- 7) Append fixed Get-RunToken (variable expansion + nice errors) ---
$fnRunToken = @'
$sa = "cryptoops-run@$Project.iam.gserviceaccount.com"
    $tok = gcloud auth print-identity-token `
             --audiences="$Audience" `
             --impersonate-service-account="$sa" 2>$null
    if (-not $tok) { throw "No token returned by gcloud." }
    return $tok
  } catch {
    throw "Get-RunToken failed: $($_.Exception.Message)"
  }
}
'@

# --- 8) Append robust Get-CloudRun5xxRatio (array-safe, property-safe) ---
$fn5xx = @'
# Filters
  $base  = ('metric.type="run.googleapis.com/request_count" AND ' +
            'resource.type="cloud_run_revision" AND ' +
            'resource.labels.service_name="{0}"') -f $Service
  $fltNum = $base + ' AND metric.labels.response_code_class="5xx"'
  $fltDen = $base

  # Query Monitoring
  try {
    $respNum = Get-MonTimeSeries -Project $Project -Filter $fltNum -StartTime $start -EndTime $end -Aggregation $agg
    $respDen = Get-MonTimeSeries -Project $Project -Filter $fltDen -StartTime $start -EndTime $end -Aggregation $agg
  } catch {
    Write-Warning "Monitoring query failed: $($_.Exception.Message)"
    return [pscustomobject]@{
      window_start_utc = $start
      window_end_utc   = $end
      service          = $Service
      last_minute      = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
      window           = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
    }
  }

  # Safely turn a timeSeries response into a numeric array (newest-last)
  function _ValuesFromResp($resp) {
    if (-not $resp -or -not ($resp.PSObject.Properties.Name -contains 'timeSeries')) { return @() }
    $ts = $resp.timeSeries
    if ($ts -isnot [System.Array]) { $ts = @($ts) }
    if (-not $ts -or $ts.Length -lt 1) { return @() }

    $series0 = $ts[0]
    if (-not ($series0.PSObject.Properties.Name -contains 'points') -or -not $series0.points) { return @() }

    $pts = $series0.points | Sort-Object { [DateTimeOffset]::Parse($_.interval.endTime) }

    $vals = New-Object 'System.Collections.Generic.List[double]'
    foreach ($p in $pts) {
      $valObj = $p.value
      if ($null -eq $valObj) { continue }
      $names = $valObj.PSObject.Properties.Name
      if     ($names -contains 'doubleValue') { $null = $vals.Add([double]$valObj.doubleValue) }
      elseif ($names -contains 'int64Value')  { $null = $vals.Add([double]$valObj.int64Value)  }
      # ignore other shapes
    }
    return $vals.ToArray()
  }

  $numVals = @(_ValuesFromResp $respNum)  # ensure true arrays
  $denVals = @(_ValuesFromResp $respDen)

  # Last aligned minute
  $lastNum   = if ($numVals.Length -gt 0) { $numVals[-1] } else { 0.0 }
  $lastDen   = if ($denVals.Length -gt 0) { $denVals[-1] } else { 0.0 }
  $lastRatio = if ($lastDen -gt 0) { [math]::Round($lastNum / $lastDen, 4) } else { $null }

  # Window totals
  $sumNum = ($numVals | Measure-Object -Sum).Sum; if ($null -eq $sumNum) { $sumNum = 0.0 }
  $sumDen = ($denVals | Measure-Object -Sum).Sum; if ($null -eq $sumDen) { $sumDen = 0.0 }
  $windowRatio = if ($sumDen -gt 0) { [math]::Round([double]$sumNum / [double]$sumDen, 4) } else { $null }

  [pscustomobject]@{
    window_start_utc = $start
    window_end_utc   = $end
    service          = $Service
    last_minute      = [pscustomobject]@{ total = $lastDen; errors_5xx = $lastNum; ratio = $lastRatio }
    window           = [pscustomobject]@{ total = $sumDen; errors_5xx = $sumNum; ratio = $windowRatio }
  }
}
'@

# --- 9) Stitch file back together + one banner at the end ---
$banner = 'Write-Host "Loaded win\ops.ps1 helpers. Dot-source this file in each new PowerShell session:  . .\win\ops.ps1"'
$new = @()
$new += $body.TrimEnd()
$new += ""
$new += $fnRunToken.Trim()
$new += ""
$new += $fn5xx.Trim()
$new += ""
$new += $banner
$newText = ($new -join [Environment]::NewLine) + [Environment]::NewLine
Set-Content $ops -Value $newText -Encoding UTF8

# --- 10) Reload into THIS session ---
. $ops

# --- 11) Sanity checks ---
Get-Command Get-RunToken,Get-CloudRun5xxRatio | Format-Table Name,Source -AutoSize
(Get-Command Get-CloudRun5xxRatio).Definition -match '\.Length' | Out-Host
(Get-Command Get-CloudRun5xxRatio).Definition -match '\.Count'  | Out-Host

function Get-RunToken {
  [CmdletBinding()]
  param(
    [string]$Audience = (Get-RunUrl),
    [string]$Project  = (gcloud config get-value core/project)
  )
  try {
    if (-not $Project) { throw "gcloud core/project is not set." }
    $sa = "cryptoops-run@$Project.iam.gserviceaccount.com"
    $tok = gcloud auth print-identity-token `
             --audiences="$Audience" `
             --impersonate-service-account="$sa" 2>$null
    if (-not $tok) { throw "No token returned by gcloud." }
    return $tok
  } catch {
    throw "Get-RunToken failed: $($_.Exception.Message)"
  }
}

function Get-CloudRun5xxRatio {
  [CmdletBinding()]
  param(
    [string]$Project = (gcloud config get-value core/project),
    [string]$Service = 'cryptoops-planner',
    [int]$WindowMinutes = 5
  )

  $end   = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
  $start = (Get-Date).ToUniversalTime().AddMinutes(-$WindowMinutes).ToString('yyyy-MM-ddTHH:mm:ssZ')

  # Per-minute deltas, sum across series, group by service
  $agg = @{
    alignmentPeriod    = '60s'
    perSeriesAligner   = 'ALIGN_DELTA'
    crossSeriesReducer = 'REDUCE_SUM'
    groupByFields      = @('resource.labels.service_name')
  }

  # Filters
  $base  = ('metric.type="run.googleapis.com/request_count" AND ' +
            'resource.type="cloud_run_revision" AND ' +
            'resource.labels.service_name="{0}"') -f $Service
  $fltNum = $base + ' AND metric.labels.response_code_class="5xx"'
  $fltDen = $base

  # Query Monitoring
  try {
    $respNum = Get-MonTimeSeries -Project $Project -Filter $fltNum -StartTime $start -EndTime $end -Aggregation $agg
    $respDen = Get-MonTimeSeries -Project $Project -Filter $fltDen -StartTime $start -EndTime $end -Aggregation $agg
  } catch {
    Write-Warning "Monitoring query failed: $($_.Exception.Message)"
    return [pscustomobject]@{
      window_start_utc = $start
      window_end_utc   = $end
      service          = $Service
      last_minute      = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
      window           = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
    }
  }

  # Safely turn a timeSeries response into a numeric array (newest-last)
  function _ValuesFromResp($resp) {
    if (-not $resp -or -not ($resp.PSObject.Properties.Name -contains 'timeSeries')) { return @() }
    $ts = $resp.timeSeries
    if ($ts -isnot [System.Array]) { $ts = @($ts) }
    if (-not $ts -or $ts.Length -lt 1) { return @() }

    $series0 = $ts[0]
    if (-not ($series0.PSObject.Properties.Name -contains 'points') -or -not $series0.points) { return @() }

    $pts = $series0.points | Sort-Object { [DateTimeOffset]::Parse($_.interval.endTime) }

    $vals = New-Object 'System.Collections.Generic.List[double]'
    foreach ($p in $pts) {
      $valObj = $p.value
      if ($null -eq $valObj) { continue }
      $names = $valObj.PSObject.Properties.Name
      if     ($names -contains 'doubleValue') { $null = $vals.Add([double]$valObj.doubleValue) }
      elseif ($names -contains 'int64Value')  { $null = $vals.Add([double]$valObj.int64Value)  }
      # ignore other shapes
    }
    return $vals.ToArray()
  }

  $numVals = @(_ValuesFromResp $respNum)  # ensure true arrays
  $denVals = @(_ValuesFromResp $respDen)

  # Last aligned minute
  $lastNum   = if ($numVals.Length -gt 0) { $numVals[-1] } else { 0.0 }
  $lastDen   = if ($denVals.Length -gt 0) { $denVals[-1] } else { 0.0 }
  $lastRatio = if ($lastDen -gt 0) { [math]::Round($lastNum / $lastDen, 4) } else { $null }

  # Window totals
  $sumNum = ($numVals | Measure-Object -Sum).Sum; if ($null -eq $sumNum) { $sumNum = 0.0 }
  $sumDen = ($denVals | Measure-Object -Sum).Sum; if ($null -eq $sumDen) { $sumDen = 0.0 }
  $windowRatio = if ($sumDen -gt 0) { [math]::Round([double]$sumNum / [double]$sumDen, 4) } else { $null }

  [pscustomobject]@{
    window_start_utc = $start
    window_end_utc   = $end
    service          = $Service
    last_minute      = [pscustomobject]@{ total = $lastDen; errors_5xx = $lastNum; ratio = $lastRatio }
    window           = [pscustomobject]@{ total = $sumDen; errors_5xx = $sumNum; ratio = $windowRatio }
  }
}

Write-Host "Loaded win\ops.ps1 helpers. Dot-source this file in each new PowerShell session:  . .\win\ops.ps1"

