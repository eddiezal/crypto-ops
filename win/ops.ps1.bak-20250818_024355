Set-StrictMode -Version Latest

function Get-Context {
  param([string]$Service='cryptoops-planner',[string]$Region='us-central1')
  $Project = (gcloud config get-value core/project)
  if (-not $Project) { throw "gcloud core/project is not set. Run: gcloud config set project <PROJECT_ID>" }
  $Bucket  = "cryptoops-state-$Project"
  $SA      = "cryptoops-run@$Project.iam.gserviceaccount.com"
  $Url     = (gcloud run services describe $Service --region $Region --format 'value(status.url)')
  [pscustomobject]@{ Project=$Project; Region=$Region; Service=$Service; Bucket=$Bucket; SA=$SA; Url=$Url }
}

function Get-RunUrl { 
  param([string]$Service='cryptoops-planner',[string]$Region='us-central1') 
  gcloud run services describe $Service --region=$Region --format='value(status.url)' 
}

function Get-RunToken { 
  param([string]$Service='cryptoops-planner',[string]$Region='us-central1') 
  $ctx=Get-Context -Service $Service -Region $Region
  gcloud auth print-identity-token --audiences=$ctx.Url --impersonate-service-account=$ctx.SA 
}

function Deploy-CryptoOps {
  param([string]$SourcePath=(Get-Location).Path,[string]$Service='cryptoops-planner',[string]$Region='us-central1')
  $ctx=Get-Context -Service $Service -Region $Region
  gcloud run deploy $ctx.Service `
    --source $SourcePath `
    --region $ctx.Region `
    --service-account $ctx.SA `
    --no-allow-unauthenticated `
    --set-env-vars ("TRADING_MODE=paper,COINBASE_ENV=sandbox,STATE_BUCKET={0},LEDGER_DB=/tmp/ledger.db,LEDGER_DB_GCS=gs://{0}/data/ledger.db" -f $ctx.Bucket) | Out-Host
  Write-Host ("Deployed {0} in {1}." -f $ctx.Service,$ctx.Region)
}

function Add-Prices {
  param([switch]$Commit,[switch]$Refresh,[string]$Service='cryptoops-planner',[string]$Region='us-central1')
  $ctx=Get-Context -Service $Service -Region $Region
  $token=Get-RunToken -Service $Service -Region $Region
  $qs=@()
  if($Commit){$qs+='commit=1'}else{$qs+='commit=0'}
  if($Refresh){$qs+='refresh=1'}
  $url="{0}/prices_append?{1}" -f $ctx.Url,($qs -join '&')
  Invoke-WebRequest $url -Headers @{Authorization="Bearer $token"} | Select-Object -ExpandProperty Content
}

function New-SchedulerJobs {
  param([string]$Service='cryptoops-planner',[string]$Region='us-central1')
  $ctx=Get-Context -Service $Service -Region $Region
  $url=$ctx.Url
  $sa=$ctx.SA
  
  function _Upsert($name,$uri,$schedule,$tz='Etc/UTC'){
    gcloud scheduler jobs describe $name --location=$ctx.Region *> $null
    if($LASTEXITCODE -ne 0){
      gcloud scheduler jobs create http $name `
        --location=$ctx.Region --schedule="$schedule" --time-zone="$tz" `
        --http-method=GET --uri="$uri" `
        --oidc-service-account-email="$sa" --oidc-token-audience="$url" | Out-Host
    } else {
      gcloud scheduler jobs update http $name `
        --location=$ctx.Region --schedule="$schedule" --time-zone="$tz" `
        --http-method=GET --uri="$uri" `
        --oidc-service-account-email="$sa" --oidc-token-audience="$url" | Out-Host
    }
  }
  
  _Upsert 'price-append-5m' ("{0}/prices_append?commit=1&refresh=1" -f $url) '1-59/5 * * * *'
  _Upsert 'apply-paper-15m' ("{0}/apply_paper?refresh=1&commit=1" -f $url) '*/15 * * * *'
  _Upsert 'snapshot-daily'  ("{0}/snapshot_now?commit=1" -f $url) '0 0 * * *'
  Write-Host ("Scheduler jobs upserted in {0} for {1}." -f $ctx.Region,$ctx.Service)
}

function New-BqExternalTables {
  param([string]$Dataset='cryptoops')
  $Project=(gcloud config get-value core/project)
  $Bucket="cryptoops-state-$Project"

  $tradesSchema=@(
    @{name='ts';type='INT64'}, @{name='symbol';type='STRING'}, @{name='side';type='STRING'},
    @{name='usd';type='FLOAT64'}, @{name='qty';type='FLOAT64'}, @{name='run_id';type='STRING'},
    @{name='revision';type='STRING'}, @{name='code_commit';type='STRING'}, @{name='plan_path';type='STRING'}
  ) | ConvertTo-Json -Depth 5
  
  $tradesDef=@{
    autodetect=$false
    sourceFormat='NEWLINE_DELIMITED_JSON'
    sourceUris=@("gs://$Bucket/trades/*.jsonl")
    schema=@{fields=(ConvertFrom-Json $tradesSchema)}
  } | ConvertTo-Json -Depth 7
  
  Set-Content "$env:TEMP\trades.def.json" -Value $tradesDef -Encoding UTF8
  bq rm -f -t --project_id=$Project "$Dataset.trades_gcs" *> $null
  bq mk --external_table_definition="$env:TEMP\trades.def.json" --project_id=$Project "$Dataset.trades_gcs" | Out-Host

  $snapSchema=@(
    @{name='ts';type='INT64'}, @{name='nav_before';type='FLOAT64'}, @{name='nav';type='FLOAT64'},
    @{name='turnover_usd';type='FLOAT64'}, @{name='actions_count';type='INT64'},
    @{name='source';type='STRING'}, @{name='revision';type='STRING'}, @{name='commit';type='BOOL'}
  ) | ConvertTo-Json -Depth 5
  
  $snapDef=@{
    autodetect=$false
    sourceFormat='NEWLINE_DELIMITED_JSON'
    sourceUris=@("gs://$Bucket/snapshots/daily.jsonl")
    schema=@{fields=(ConvertFrom-Json $snapSchema)}
  } | ConvertTo-Json -Depth 7
  
  Set-Content "$env:TEMP\snapshots.def.json" -Value $snapDef -Encoding UTF8
  bq rm -f -t --project_id=$Project "$Dataset.snapshots_daily" *> $null
  bq mk --external_table_definition="$env:TEMP\snapshots.def.json" --project_id=$Project "$Dataset.snapshots_daily" | Out-Host
}

function New-BqViews {
  param([string]$Dataset='cryptoops')
  $Project=(gcloud config get-value core/project)
  
  $v1="SELECT TIMESTAMP_SECONDS(CAST(ts AS INT64)) AS ts_utc, symbol, side, usd, qty FROM $Dataset.trades_gcs WHERE ts >= UNIX_SECONDS(TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)) ORDER BY ts DESC"
  bq mk --project_id=$Project --use_legacy_sql=false --view "$v1" "$Dataset.v_trades_last_7d" *> $null
  
  $v2="SELECT TIMESTAMP_SECONDS(CAST(ts AS INT64)) AS ts_utc, nav, nav_before, actions_count, source, revision FROM $Dataset.snapshots_daily ORDER BY ts"
  bq mk --project_id=$Project --use_legacy_sql=false --view "$v2" "$Dataset.v_nav" *> $null
}

function Invoke-BqTradesLast20 { 
  param([string]$Dataset='cryptoops') 
  $Project=(gcloud config get-value core/project)
  $sql="SELECT TIMESTAMP_SECONDS(CAST(ts AS INT64)) AS ts_utc, symbol, side, usd, qty, run_id FROM $Dataset.trades_gcs ORDER BY ts DESC LIMIT 20"
  bq query --project_id=$Project --use_legacy_sql=false "$sql" 
}

function Invoke-BqSnapshotsLast50 { 
  param([string]$Dataset='cryptoops') 
  $Project=(gcloud config get-value core/project)
  $sql="SELECT TIMESTAMP_SECONDS(CAST(ts AS INT64)) AS ts_utc, nav, nav_before, actions_count, source, revision FROM $Dataset.snapshots_daily ORDER BY ts DESC LIMIT 50"
  bq query --project_id=$Project --use_legacy_sql=false "$sql" 
}

function New-MonEmailChannel {
  param(
    [Parameter(Mandatory)][string]$Email,
    [string]$DisplayName='Ops email'
  )
  
  $name = gcloud alpha monitoring channels create `
    --display-name="$DisplayName" `
    --type=email `
    --channel-labels="email_address=$Email" `
    --format="value(name)"
    
  if(-not $name) { throw "Failed to create channel." }
  
  $token = gcloud auth print-access-token
  $uri = "https://monitoring.googleapis.com/v3/{0}:sendVerificationCode" -f $name
  
  Invoke-RestMethod -Method POST -Uri $uri `
    -Headers @{Authorization="Bearer $token"; "Content-Type"="application/json"} `
    -Body "{}" | Out-Null
    
  Write-Host "Sent verification code to $Email. Now run: Confirm-MonEmailChannel -ChannelName '$name' -Code <6digits>"
  return $name
}

function Confirm-MonEmailChannel {
  param(
    [Parameter(Mandatory)][string]$ChannelName,
    [Parameter(Mandatory)][string]$Code
  )
  
  $token = gcloud auth print-access-token
  $uri = "https://monitoring.googleapis.com/v3/{0}:verify" -f $ChannelName
  
  Invoke-RestMethod -Method POST -Uri $uri `
    -Headers @{Authorization="Bearer $token"; "Content-Type"="application/json"} `
    -Body (@{code=$Code} | ConvertTo-Json) | Out-Null
    
  gcloud alpha monitoring channels describe "$ChannelName" --format="table(name,displayName,verificationStatus)"
}

function New-MonPolicies {
  param(
    [Parameter(Mandatory)][string]$ChannelId,
    [string]$Service='cryptoops-planner'
  )
  
  $Project = (gcloud config get-value core/project)

  # 5xx error rate > 5% policy
  $policy5 = @{
    displayName = "Cloud Run 5xx error rate > 5% ($Service)"
    enabled = $true
    combiner = "OR"
    documentation = @{
      content = "Fires when 5xx error rate > 5% for 5 minutes on **$Service** in project '$Project'."
      mimeType = "text/markdown"
    }
    notificationChannels = @("projects/$Project/notificationChannels/$ChannelId")
    conditions = @(@{
      displayName = "5xx ratio > 5% (5 min)"
      conditionThreshold = @{
        filter = "resource.type=""cloud_run_revision"" AND resource.labels.service_name=""$Service"" AND metric.type=""run.googleapis.com/request_count"" AND metric.labels.response_code_class=""5xx"""
        aggregations = @(@{
          alignmentPeriod = "60s"
          perSeriesAligner = "ALIGN_DELTA"
          crossSeriesReducer = "REDUCE_SUM"
        })
        denominatorFilter = "resource.type=""cloud_run_revision"" AND resource.labels.service_name=""$Service"" AND metric.type=""run.googleapis.com/request_count"""
        denominatorAggregations = @(@{
          alignmentPeriod = "60s"
          perSeriesAligner = "ALIGN_DELTA"
          crossSeriesReducer = "REDUCE_SUM"
        })
        comparison = "COMPARISON_GT"
        thresholdValue = 0.05
        duration = "300s"
        trigger = @{count = 1}
      }
    })
    userLabels = @{service = $Service}
  }

  # P95 latency > 2s policy
  $policyLat = @{
    displayName = "Cloud Run p95 latency > 2s ($Service)"
    enabled = $true
    combiner = "OR"
    documentation = @{
      content = "Fires when p95 request latency > 2s for 5 minutes on **$Service** in project '$Project'."
      mimeType = "text/markdown"
    }
    notificationChannels = @("projects/$Project/notificationChannels/$ChannelId")
    conditions = @(@{
      displayName = "p95 latency > 2s (5 min)"
      conditionThreshold = @{
        filter = "resource.type=""cloud_run_revision"" AND resource.labels.service_name=""$Service"" AND metric.type=""run.googleapis.com/request_latencies"""
        aggregations = @(@{
          alignmentPeriod = "60s"
          perSeriesAligner = "ALIGN_PERCENTILE_95"
          crossSeriesReducer = "REDUCE_MAX"
        })
        comparison = "COMPARISON_GT"
        thresholdValue = 2000
        duration = "300s"
        trigger = @{count = 1}
      }
    })
    userLabels = @{service = $Service}
  }

  $p5 = "$env:TEMP\mon5xx.json"
  $pl = "$env:TEMP\monlat.json"
  
  ($policy5 | ConvertTo-Json -Depth 20) | Set-Content $p5 -Encoding UTF8
  ($policyLat | ConvertTo-Json -Depth 20) | Set-Content $pl -Encoding UTF8
  
  gcloud alpha monitoring policies create --policy-from-file="$p5" | Out-Host
  gcloud alpha monitoring policies create --policy-from-file="$pl" | Out-Host
  
  gcloud alpha monitoring policies list --filter="displayName:$Service" --format="table(name,displayName,enabled)"
}

function Get-MonTimeSeries {
  param(
    [Parameter(Mandatory)][string]$Project,
    [Parameter(Mandatory)][string]$Filter,
    [Parameter(Mandatory)][string]$StartTime,
    [Parameter(Mandatory)][string]$EndTime,
    [hashtable]$Aggregation = @{}
  )
  
  $accessToken = gcloud auth print-access-token
  $base = "https://monitoring.googleapis.com/v3/projects/$Project/timeSeries"
  
  $qsParts = @(
    "interval.startTime=$([uri]::EscapeDataString($StartTime))",
    "interval.endTime=$([uri]::EscapeDataString($EndTime))",
    "filter=$([uri]::EscapeDataString($Filter))"
  )
  
  if($Aggregation) {
    if($Aggregation.alignmentPeriod) {
      $qsParts += "aggregation.alignmentPeriod=$($Aggregation.alignmentPeriod)"
    }
    if($Aggregation.perSeriesAligner) {
      $qsParts += "aggregation.perSeriesAligner=$($Aggregation.perSeriesAligner)"
    }
    if($Aggregation.crossSeriesReducer) {
      $qsParts += "aggregation.crossSeriesReducer=$($Aggregation.crossSeriesReducer)"
    }
    if($Aggregation.groupByFields) { 
      foreach($g in $Aggregation.groupByFields) { 
        $qsParts += "aggregation.groupByFields=$([uri]::EscapeDataString($g))" 
      } 
    }
  }
  
  $qs = $qsParts -join '&'
  Invoke-RestMethod -Method GET -Headers @{Authorization="Bearer $accessToken"} -Uri "$base`?$qs"
}

function Get-CloudRunP95 {
  param(
    [string]$Project = (gcloud config get-value core/project),
    [string]$Service = 'cryptoops-planner',
    [int]$WindowMinutes = 5
  )
  
  $end = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
  $start = (Get-Date).ToUniversalTime().AddMinutes(-$WindowMinutes).ToString("yyyy-MM-ddTHH:mm:ssZ")
  
  $filter = 'metric.type="run.googleapis.com/request_latencies" AND resource.type="cloud_run_revision" AND resource.labels.service_name="' + $Service + '"'
  
  $resp = Get-MonTimeSeries -Project $Project -Filter $filter -StartTime $start -EndTime $end -Aggregation @{
    alignmentPeriod = '60s'
    perSeriesAligner = 'ALIGN_PERCENTILE_95'
    crossSeriesReducer = 'REDUCE_MAX'
    groupByFields = @('resource.labels.service_name')
  }
  
  $rows = @()
  foreach($ts in ($resp.timeSeries | ForEach-Object {$_})) {
    foreach($pt in $ts.points) {
      $v = $pt.value.doubleValue
      if(-not $v) { $v = $pt.value.int64Value }
      $rows += [pscustomobject]@{
        minute_end_utc = [DateTimeOffset]::Parse($pt.interval.endTime).UtcDateTime
        p95_ms = [math]::Round([double]$v, 0)
      }
    }
  }
  
  $rows | Sort-Object minute_end_utc
}

function Get-CloudRun5xxRatio {
  [CmdletBinding()]
  param(
    [string]$Project = (gcloud config get-value core/project),
    [string]$Service = 'cryptoops-planner',
    [int]$WindowMinutes = 5
  )

  $end = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
  $start = (Get-Date).ToUniversalTime().AddMinutes(-$WindowMinutes).ToString('yyyy-MM-ddTHH:mm:ssZ')

  # Per-minute deltas, sum across series, group by service
  $agg = @{
    alignmentPeriod = '60s'
    perSeriesAligner = 'ALIGN_DELTA'
    crossSeriesReducer = 'REDUCE_SUM'
    groupByFields = @('resource.labels.service_name')
  }

  # Filters
  $base = ('metric.type="run.googleapis.com/request_count" AND ' +
           'resource.type="cloud_run_revision" AND ' +
           'resource.labels.service_name="{0}"') -f $Service
  $fltNum = $base + ' AND metric.labels.response_code_class="5xx"'
  $fltDen = $base

  # Query Monitoring
  try {
    $respNum = Get-MonTimeSeries -Project $Project -Filter $fltNum -StartTime $start -EndTime $end -Aggregation $agg
    $respDen = Get-MonTimeSeries -Project $Project -Filter $fltDen -StartTime $start -EndTime $end -Aggregation $agg
  }
  catch {
    Write-Warning "Failed to query monitoring API: $_"
    return [pscustomobject]@{
      window_start_utc = $start
      window_end_utc = $end
      service = $Service
      last_minute = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
      window = [pscustomobject]@{ total = $null; errors_5xx = $null; ratio = $null }
    }
  }

  # Helper function to extract values safely
  function Get-TimeSeriesValues($resp) {
    $values = @()
    if ($null -eq $resp) { return $values }
    if (-not ($resp.PSObject.Properties.Name -contains 'timeSeries')) { return $values }
    
    $ts = $resp.timeSeries
    if ($null -eq $ts -or $ts.Length -eq 0) { return $values }
    
    $series = if ($ts -is [System.Array]) { $ts[0] } else { $ts }
    if (-not ($series.PSObject.Properties.Name -contains 'points')) { return $values }
    if ($null -eq $series.points) { return $values }
    
    $points = $series.points | Sort-Object { [DateTimeOffset]::Parse($_.interval.endTime) }
    
    foreach ($pt in $points) {
      $v = $null
      if ($pt.value) {
        if ($pt.value.PSObject.Properties.Name -contains 'doubleValue') {
          $v = [double]$pt.value.doubleValue
        }
        elseif ($pt.value.PSObject.Properties.Name -contains 'int64Value') {
          $v = [double]$pt.value.int64Value
        }
      }
      if ($null -ne $v) {
        $values += $v
      }
    }
    
    return $values
  }

  $numVals = Get-TimeSeriesValues $respNum
  $denVals = Get-TimeSeriesValues $respDen

  # Calculate last minute values
  $lastNum = if ($numVals.Length -gt 0) { $numVals[-1] } else { 0.0 }
  $lastDen = if ($denVals.Length -gt 0) { $denVals[-1] } else { 0.0 }
  $lastRatio = if ($lastDen -gt 0) { [math]::Round($lastNum / $lastDen, 4) } else { $null }

  # Calculate window totals
  $sumNum = ($numVals | Measure-Object -Sum).Sum
  $sumDen = ($denVals | Measure-Object -Sum).Sum
  if ($null -eq $sumNum) { $sumNum = 0.0 }
  if ($null -eq $sumDen) { $sumDen = 0.0 }
  $windowRatio = if ($sumDen -gt 0) { [math]::Round($sumNum / $sumDen, 4) } else { $null }

  [pscustomobject]@{
    window_start_utc = $start
    window_end_utc = $end
    service = $Service
    last_minute = [pscustomobject]@{ 
      total = $lastDen
      errors_5xx = $lastNum
      ratio = $lastRatio 
    }
    window = [pscustomobject]@{ 
      total = $sumDen
      errors_5xx = $sumNum
      ratio = $windowRatio 
    }
  }
}

function Enable-DebugEndpoints { 
  param([string]$Service='cryptoops-planner',[string]$Region='us-central1') 
  gcloud run services update $Service --region $Region --update-env-vars ENABLE_DEBUG_ENDPOINTS=1 | Out-Host 
}

function Disable-DebugEndpoints { 
  param([string]$Service='cryptoops-planner',[string]$Region='us-central1') 
  gcloud run services update $Service --region $Region --update-env-vars ENABLE_DEBUG_ENDPOINTS=0 | Out-Host 
}

Write-Host "Loaded win\ops.ps1 helpers. Dot-source this file in each new PowerShell session:  . .\win\ops.ps1"